# Phiwokwakhe Khathwane : 2022004325
# Welcome Galane        : 2024671386 

import cv2
import base64
import numpy as np
import services.service as sv

# Computer vision model used for shape detection
#  - The model utilizes HSV(Hue Saturation and Value) color ranges defined in the "services/service.py" file
#    to mask the image
#  - It then detects closed contour lines and predicts the shape if the area enclosed
#    by the contour is greater than the minimum threshold, `min_area`

class ComputerVisionModel:
    def __init__(self, min_area=100):
        self.min_area = min_area
        self.shapes = sv.shapes;
    
    #Method for detecting the shape recieving:
    # - The base64 encoded image which will be decoded
    # - HSV color ranges(upper and lower bounds) for the colour of the shape to be detected(front-end will detect it)
    def detect_shape(self, image_base64, hsv_color_ranges: list[tuple[list,list]]) -> list:
        image = self._decode_image(image_base64=image_base64)
        if image is None:
            return []
        
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        mask = None
        #Using the hsv colour ranges, create a mask by using a 'bitwise or ' operator
        for lower, upper in hsv_color_ranges:
            lower_np = np.array(lower)
            upper_np = np.array(upper)
            current_mask = cv2.inRange(hsv, lower_np, upper_np)
            mask = current_mask if mask is None else cv2.bitwise_or(mask, current_mask)

        #mask image using mask to detect shape contours
        mask_uint8 = np.ascontiguousarray(mask, dtype=np.uint8)

        #Get all the bounding lines of the colors detected
        contours, _ = cv2.findContours(mask_uint8, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        shapes: list[tuple[str,float]] = []
        for cnt in contours:
            #Shape must be within the minimum allowed area, otherwise we ignore
            shape_area = cv2.contourArea(cnt)
            if shape_area >= self.min_area:
                shape_type = self._determine_shape_type(cnt)
                if shape_type in self.shapes: 
                    shapes.append((shape_type, shape_area))
        
        #return the shapes with the largest area(incase they are equally large)
        return self._detemine_largest_shapes(shapes)
    
    #Method to determine the largest shape based on the shape areas
    #- if two shapes are equally large, both will be returned
    @staticmethod
    def _detemine_largest_shapes(shapes: list[tuple[str,float]]) -> list:
        if not shapes:
            return []
        
        #determine the max area
        max_area = max(area for _, area in shapes)
        #find all shapes with the same largest area
        largest_shapes = [shape for shape, area in shapes if area == max_area]
        
        return largest_shapes

    # Method for determining the shapes detected using the contor map generated by the color mask
    @staticmethod 
    def _determine_shape_type(contor_map) -> str:
        #estimate the number of vertices from the contor map
        #-epsilon = 4% for better approximation for circles
        vertices_approx  = cv2.approxPolyDP(contor_map, 0.04 * cv2.arcLength(contor_map, True), True)
        
        if len(vertices_approx) == 3:
            return"triangle" 

        if len(vertices_approx) == 4:
            _, _, w, h = cv2.boundingRect(vertices_approx)
            aspect_ratio = float(w) / h

            #For squares, they should have almost the same width and height(aspect ratio should be close to 1)
            if 0.90 <= aspect_ratio <= 1.10:
                return "square"
            else:
                return "rectangle"
        
        #Anything with verticies more than 4 could potentially be a circle
        #-For an exact shape, we 
        if len(vertices_approx) > 4:
            area = cv2.contourArea(contor_map)
            perimeter = cv2.arcLength(contor_map, True)
            if perimeter == 0:
                return ''
            #For a circles, the circularity should be 1(or really close to it)
            circularity = 4 * np.pi * (area / (perimeter * perimeter))
            if circularity > 0.7:
                return "circle"

        return ''
    #Method used for decoding a base64 image and reads it
    @staticmethod
    def _decode_image(image_base64):
        try:
            image_data = base64.b64decode(image_base64)
            np_arr = np.frombuffer(image_data, np.uint8)
            image = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
            return image
        except Exception as e:
            print(f"Error decoding image: {e}")
            return None